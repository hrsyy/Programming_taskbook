<html>

<head> 
<title>Некоторые примеры программирования </title> 
<meta http-equiv = "content-type" content = "text/html; charset = windows-1251">
<link rel="stylesheet" type="text/css" href="..\files\style.css">
</head>

<body BACKGROUND = "../files/foni.gif">
<a name="Glava36"></a>
<A href="../files/oglav.htm">Оглавление</A><BR>
<h2>§36 Некоторые примеры программирования</h2>

<ol>
<div>
<P><b><a name="z1047">1047 </a></b>При программировании практических задач часто приходится работать с 
различными списками. Ппимерами могут служить список учеников 9а класса, список учителейлей, преподающих 
литературу во всех 10-х классах школы, список участников спортивной игры и т. п. Каждый элемент списка 
содержит, как правило, несколько полей. Например, элементы списка выпускников школы могут включать имя 
и фамилию ученика, а также его средний балл по аттестату.<br>Представление списков в памяти ЭВМ может 
быть основано на последовательном и на связанном распределении памяти. При последовательном распределении 
элементы списка (будем также называть их узлами) размещаются последовательно, один за другим. При связанном 
распределении памяти местоположение каждого элемента заранее неизвестно - блок памяти, который отводится 
для размещения отдельного элемента, выделяется из одной большей области памяти по специальным алгоритмам 
(см. задачу 1052). Поэтому все узлы содержат по крайней мере одно дополнительное поле - поле связи со следующим 
(рис. 120, а) или предыдущим узлом (рис. 120,6) (см. также задачи <a href="../Glava14/index14.htm#z531">531</a>, 
<a href="../Glava14/index14.htm#z532">532</a>). На рис. 120 FIRST - это переменная, 
указывающая на первый узел в списке; LAST - переменная, указывающая на последний узел в списке; стрелки 
обозначаютсвязи между узлами; NIL - значение поля связи, говорящее о том, что данный узел не связан ни с каким 
другим узлом (является последним ца рис. 120, а и первым на рис. 120,6).<p align="center"><img src="image01.gif"></p>
Связанное распределение памяти обеспечивает существенно более высокую гибкость при работе со списками, чем 
последовательное распределение, значительно упрощая включение нового узла в список и исключение из него.
<br>Наиболее часто используются следующие виды связанного распределения памяти (далее, под термином список мы 
будем понимать конкретное представление соответствующей информационной структуры в памяти ЭВМ на основе 
связанного распределения памяти):
  <ol>
    1) Односвязные списки, в которых каждый элемент содержит поле связи либо со следующим, либо с предыдущим 
		   элементом списка (рис. 120).<br>
		2) Односвязные циклические списки, в которых последний элемент содержит поле связи с первым элементом 
		   (рис. 121) (см. задачу <a href="../Glava14/index14.htm#z545">545</a>).<p align="center"><img src="image02.gif"></p>
    3) Двусвязные списки, в которых каждый элемент содержит поле связи со следующим элементом и с предыдущим 
		   (рис. 122) (см. задачу <a href="../Glava14/index14.htm#z533">533</a>).<p align="center"><img src="image03.gif"></p> 
  </ol>
<p>При работе с линейными списками требуется, как правило, выполнять следующие операции [34]:
  <ol>
	  <br>
    1) Получить доступ к k - му узлу списка, чтобы проанализировать и/или изменить содержимое его полей.<br>
		2) Включить новый узел непосредственно перед k - м узлом.<br>
		3) Исключить k - й узел.<br>
		4) Объединить два (или более) списка в один список.<br>
		5) Разбить список на два (или более) списка.<br>
		6) Сделать копию списка.<br>
		7) Определить число узлов в списке.<br>
		8) Выполнить сортировку узлов списка по значениям некоторых полей.<br>
		9) Найти в списке узел с заданным значением некоторого поля.
  </ol>
<br>Составить процедуры, реализующие перечисленные выше операции 1)-9) для работы с односвязными, односвязными 
циклическими и двусвязными списками.</p>

<b><a name="z1048">1048 </a></b> Одним из наиболее часто встречающихся видов списка является стек-список, в 
котором все включения и исключения элементов делаются только на одном его конце - вершине стека (рис. 123). 
Механизм функционирования стека хорошо отражен в другом его названии- список типа "LIFO" (last in first out- 
"последним вошел - первым вышел"). При работе со стеком предполагаются две операции: занесение очередного 
элемента в вершину стека и удаление элемента, находящегося в вершине стека. Тем самым операция удаления 
элемента из стека может быть применена только к элементу, помещенному в стек самым последним. И, следовательно, 
любой элемент не может быть удален из стека раньше, чем будут удалены все элементы, помещенные в стек после 
него.<p align="center"><img src="image04.gif"></p> Составить процедуры, реализующие операции занесения элемента в стек и 
удаления элемента из его вершины.<p align="center"><img src="image05.gif"></p>

<P><b><a name="z1049">1049 </a></b> Еще один из наиболее важных видов структур, встречающихся в программировании, 
представляют собой деревья. Формально дерево (рис. 124) определяется как конечное множество T, состоящее из 
одного или более узлов таких, что
  <ol>
    1) имеется один узел, называемый корнем дерева;<br>
		2) остальные узлы (исключая корень) содержатся в m > 0 попарно непересекающихся множествах 
       T<sub>1</sub>, .... T<sub>m</sub>, каждое из которых в свою очередь является деревом;
  </ol>
деревья T<sub>1</sub>, .... T<sub>m</sub> называются поддеревьями данного корня [34]. Деревья, как правило, 
дают хорошее представление о структурных отношениях между элементами данных. Так, например, на рис. 125 
показано дерево, представляющее формулу (АВ + CD)/BC. Здесь ветвь, отходящая от вершины / влево, представляет 
числитель дроби, а ветвь, отходящая вправо,- ее знаменатель и т. д.<p align="center"><img src="image06.gif"></p>
Еще один пример - фрагмент дерева (рис. 126), показывающего возможные ходы при игре в восемь (эта игра аналогична 
игре в пятнадцать); исходная и целевая позиции приведены соответственно на рис. 127, и и 127,6 [41]. Далее мы 
будем рассматривать только бинарные деревья. Бинарное дерево определяется как конечное множество узлов, которое 
либо пусто, либо состоит из корня и двух бинарных деревьев (рис. 128). При рзаботе с древовидными структурами 
наиболее часто приходится решать задачу обхода дерева - такого последовательного прохождения по узлам дерева, 
когда каждый узел встречается ровно один раз. Для обхода бинарного дерева можно воспользоваться одним из трех 
способов: можно проходить узлы в префиксном порядке, в инфиксном порядке и в суффиксном порядке.
<p align="center"><img src="image07.gif"></p>Префиксный порядок обхода дерева определяется в виде списка проходимых узлов следующим 
образом. Если дерево не пусто, префиксный порядок - это корень дерева; узлы левого поддерева в префиксном порядке; 
узлы правого поддерева в префиксном порядке. Инфиксный порядок обхода дерева определяется следующим образом. 
Если дерево пусто, список узлов пуст. Если дерево не пусто, инфиксивный порядок - это узлы левого поддерева в 
инфиксном порядке; корень дерева; узлы правого поддерева в инфиксном порядке. Суффиксный порядок обхода дерева 
определяется следующим образом. Если дерево пусто, список узлов пуст. Если дерево не пусто, суффиксный порядок - 
это узлы левого поддерева в суффиксном порядке;узлы правого поддерева в суффиксном порядке;корень дерева. 
Составить процедуры обхода заданного бинарного дерева в префиксном, инфиксном и суффиксном порядке.</p>

<P><b><a name="z1050">1050 </a></b>Составить процедуру подсчета числа узлов заданного бинарного дерева.</p>

<P><b><a name="z1051">1051 </a></b>Листом дерева называется вершина, не являющаяся корнем никакого поддерева. 
Составить процедуру подсчета числа листьев заданного бинарного дерева.</p>

<P><b><a name="z1052">1052 </a></b>Алгоритмами динамического распределения памяти называют алгоритмы, 
позволяющие выделять и освобождать различные по размеру блоки памяти, беря их из одной большой области 
памяти. (Здесь и далее используются термины блок и область, обозначающие совокупность смежных ячеек памяти.)<br>
<dl> Будем считать, что вся имеющаяся свободная память представлена 
в виде списка свободных блоков. В начальный момент в списке только один блок, содержащий всю свободную память. 
Каждый блок содержит заголовок с размерами блока и указателем на следующий блок. Выделение свободной памяти по 
запросу часто выполняется либо по методу "наиболее подходящего", либо по методу "первого подходящего".</dl> 
<dl>Метод "наиболее подходящего" заключается в том, что среди всех 
блоков, имеющих размер, не меньший требуемого, выбирается блок с наименьшим размером. Метод "первого подходящего" 
заключается в том, что выделению подлежит первый в порядке просмотра элементов списка блок, размер которого не 
меньше требуемого.</dl><dl> Если блок, выбранный по одному из двух 
указанных методов, имеет размер, превышающий указанный при запросе, он расщепляется на два: первый блок имеет 
требуемый размер и предоставляется в ответ на запрос, второй блок - остаток - остается в списке свободной памяти. 
При освобождении блока смежные блоки склеиваются.</dl><dl>Реализовать 
процедуру для выделения блока свободной памяти заданного размера (результатом работы процедуры должна быть -1, 
если блок такого размера выделен быть не может) и процедуру для освобождения - повторного включения в список 
свободной памяти блока, выделенного ранее.</dl>
</div>
</ol>

<table noborder width="65%">
 <tr>
  <td align="left">  <font size="5"><a href="..\glava35\index35.htm#Glava35"><img border="0" src="..\files\arrow_l.gif">Предыдущая глава</a></font></td>
  <td align="center"><font size="5"><a href="#Glava36">К началу</a></font></td>
 </tr>
</table>

</body>
</html>